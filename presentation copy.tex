\documentclass[aspectratio=169]{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[bulgarian]{babel}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}
\usetikzlibrary{arrows.meta, positioning, shapes}

\usetheme{Madrid}
\usecolortheme{default}

% Настройки за код
\lstset{
    language=C++,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!60!black},
    stringstyle=\color{red},
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=5pt,
    backgroundcolor=\color{gray!10},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    escapeinside={(*@}{@*)},
    morekeywords={thread, mutex, condition_variable, unique_lock, shared_ptr},
    literate=%
        {а}{{\selectfont\char224}}1 {б}{{\selectfont\char225}}1
        {в}{{\selectfont\char226}}1 {г}{{\selectfont\char227}}1
        {д}{{\selectfont\char228}}1 {е}{{\selectfont\char229}}1
        {ж}{{\selectfont\char230}}1 {з}{{\selectfont\char231}}1
        {и}{{\selectfont\char232}}1 {й}{{\selectfont\char233}}1
        {к}{{\selectfont\char234}}1 {л}{{\selectfont\char235}}1
        {м}{{\selectfont\char236}}1 {н}{{\selectfont\char237}}1
        {о}{{\selectfont\char238}}1 {п}{{\selectfont\char239}}1
        {р}{{\selectfont\char240}}1 {с}{{\selectfont\char241}}1
        {т}{{\selectfont\char242}}1 {у}{{\selectfont\char243}}1
        {ф}{{\selectfont\char244}}1 {х}{{\selectfont\char245}}1
        {ц}{{\selectfont\char246}}1 {ч}{{\selectfont\char247}}1
        {ш}{{\selectfont\char248}}1 {щ}{{\selectfont\char249}}1
        {ъ}{{\selectfont\char250}}1 {ь}{{\selectfont\char252}}1
        {ю}{{\selectfont\char254}}1 {я}{{\selectfont\char255}}1
        {А}{{\selectfont\char192}}1 {Б}{{\selectfont\char193}}1
        {В}{{\selectfont\char194}}1 {Г}{{\selectfont\char195}}1
        {Д}{{\selectfont\char196}}1 {Е}{{\selectfont\char197}}1
        {Ж}{{\selectfont\char198}}1 {З}{{\selectfont\char199}}1
        {И}{{\selectfont\char200}}1 {Й}{{\selectfont\char201}}1
        {К}{{\selectfont\char202}}1 {Л}{{\selectfont\char203}}1
        {М}{{\selectfont\char204}}1 {Н}{{\selectfont\char205}}1
        {О}{{\selectfont\char206}}1 {П}{{\selectfont\char207}}1
        {Р}{{\selectfont\char208}}1 {С}{{\selectfont\char209}}1
        {Т}{{\selectfont\char210}}1 {У}{{\selectfont\char211}}1
        {Ф}{{\selectfont\char212}}1 {Х}{{\selectfont\char213}}1
        {Ц}{{\selectfont\char214}}1 {Ч}{{\selectfont\char215}}1
        {Ш}{{\selectfont\char216}}1 {Щ}{{\selectfont\char217}}1
        {Ъ}{{\selectfont\char218}}1 {Ь}{{\selectfont\char220}}1
        {Ю}{{\selectfont\char222}}1 {Я}{{\selectfont\char223}}1
}

\title{Модерни техники за паралелизъм и асинхронност в C++}
\subtitle{Thread Pools, Coroutines и Publisher/Subscriber Pattern}
\author{Алекс Цветанов, КСИ, ФКСТ, 121222225}
\institute{Паралелно програмиране}
\date{\today}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}{План на лекцията}
\begin{columns}[t]
\column{0.5\textwidth}
\tableofcontents[sections={1-3}]

\column{0.5\textwidth}
\tableofcontents[sections={4-6}]
\end{columns}
\end{frame}

\section{Увод: Паралелизъм vs Асинхронност}

\begin{frame}{Мотивация}
\begin{columns}
\column{0.5\textwidth}
\textbf{Защо е важно?}
\begin{itemize}
    \item Съвременните CPU имат множество ядра
    \item I/O операциите блокират нишки
    \item Нуждата от high-throughput системи
    \item Скалируемост и ефективност
\end{itemize}

\column{0.5\textwidth}
\textbf{Нашият фокус днес:}
\begin{enumerate}
    \item Thread Pools (паралелизъм)
    \item Coroutines (асинхронност)
    \item Publisher/Subscriber (комуникация)
    \item Lock-free структури
    \item Практически имплементации
\end{enumerate}
\end{columns}

\vspace{0.5cm}
\centering
\textit{Как да използваме ресурсите оптимално?}
\end{frame}

\begin{frame}{Паралелизъм vs Асинхронност}
\begin{center}
\begin{tikzpicture}[scale=0.7]
    % Parallelism - LEFT SIDE
    \node[font=\bfseries] at (0,2.8) {Паралелизъм};
    \draw[fill=green!20, thick] (0,1.8) rectangle (1.5,2.3) node[pos=.5] {\tiny Task 1};
    \draw[fill=green!20, thick] (0,1.2) rectangle (1.5,1.7) node[pos=.5] {\tiny Task 2};
    \draw[fill=green!20, thick] (0,0.6) rectangle (1.5,1.1) node[pos=.5] {\tiny Task 3};
    \node[right, align=left] at (1.7,1.4) {\small Едновременно\\[-2pt]\small изпълнение};
    
    % Concurrency/Async - RIGHT SIDE
    \node[font=\bfseries] at (7,2.8) {Асинхронност};
    % Row 1
    \draw[fill=blue!20, thick] (5.5,2.0) rectangle (6.3,2.4) node[pos=.5] {\tiny T1};
    \draw[fill=red!20, thick] (6.4,2.0) rectangle (7.0,2.4) node[pos=.5] {\tiny T2};
    \draw[fill=blue!20, thick] (7.1,2.0) rectangle (7.9,2.4) node[pos=.5] {\tiny T1};
    % Row 2
    \draw[fill=red!20, thick] (5.5,1.4) rectangle (6.1,1.8) node[pos=.5] {\tiny T2};
    \draw[fill=yellow!40, thick] (6.2,1.4) rectangle (7.0,1.8) node[pos=.5] {\tiny T3};
    \draw[fill=blue!20, thick] (7.1,1.4) rectangle (7.9,1.8) node[pos=.5] {\tiny T1};
    
    \node[right, align=left] at (8.1,1.7) {\small Чередуване};
\end{tikzpicture}
\end{center}

\vspace{0.3cm}
\textbf{Thread Pools:} истински паралелизъм (multiple cores) \\
\textbf{Coroutines:} кооперативна многозадачност (single core OK)
\end{frame}

\section{Thread Pools}

\subsection{Концепция}

\begin{frame}{Thread Pool: Концепция}
\begin{center}
\begin{tikzpicture}[scale=0.8,
    task/.style={rectangle, draw, fill=orange!30, minimum width=0.6cm, minimum height=0.4cm},
    thread/.style={rectangle, draw, fill=blue!20, minimum width=1.5cm, minimum height=0.6cm}]
    
    % Task Queue
    \node[font=\bfseries] at (-2,3.5) {Task Queue};
    \draw[thick] (-4,2) rectangle (0,3);
    \node[task] at (-3.5,2.5) {T1};
    \node[task] at (-2.8,2.5) {T2};
    \node[task] at (-2.1,2.5) {T3};
    \node[task] at (-1.4,2.5) {T4};
    \node[task] at (-0.7,2.5) {T5};
    \node at (-0.2,2.5) {...};
    
    % Thread Pool
    \node[font=\bfseries] at (4,3.5) {Thread Pool};
    \node[thread] (t1) at (4,2.7) {Worker 1};
    \node[thread] (t2) at (4,1.9) {Worker 2};
    \node[thread] (t3) at (4,1.1) {Worker 3};
    \node at (4,0.5) {...};
    
    % Arrows
    \draw[-Latex, thick, red] (-0.2,2.5) -- (t1.west);
    \draw[-Latex, thick, red] (-0.2,2.5) -- (t2.west);
    \draw[-Latex, thick, red] (-0.2,2.5) -- (t3.west);
\end{tikzpicture}
\end{center}

\textbf{Идея:} Фиксиран брой worker нишки, които обработват задачи от споделена опашка

\vspace{0.3cm}
\textbf{Предимства:}
\begin{itemize}
    \item Контрол върху броя нишки
    \item Преизползване на ресурси
    \item По-добра производителност
\end{itemize}
\end{frame}

\subsection{Защо е необходим?}

\begin{frame}[fragile]{Защо Thread Pool? Цената на създаване на нишки}

\textbf{Проблем:} Създаването и унищожаването на std::thread обекти е скъпа операция! \\

\begin{columns}
\column{0.45\textwidth}
\textbf{Наивен подход:}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
// Създаване на нова нишка 
// за ВСЯКА задача
for (auto& task : tasks) {
    std::thread t([&task]() {
        process(task);
    });
    t.detach(); // Опасно!
}

// Проблеми:
// 1. System call за създаване
// 2. Заделяне на stack памет
// 3. Context switching overhead
// 4. Унищожаване на ресурси
// 5. Няма контрол върху броя
\end{lstlisting}

\column{0.45\textwidth}
\textbf{Thread Pool подход:}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
// Еднократно създаване
ThreadPool pool(
    std::thread::
    hardware_concurrency()
);

// Многократно използване
for (auto& task : tasks) {
    pool.enqueue([&task]() {
        process(task);
    });
}
pool.wait_all();

// Предимства:
// 1. Нишките се създават веднъж
// 2. Преизползване на ресурси
// 3. Контролиран паралелизъм
// 4. По-добра cache locality
\end{lstlisting}
\end{columns}

\vspace{0.2cm}
\centering
\textbf{Benchmark:} Създаване на 1000 нишки $\approx$ 50-100ms, Thread Pool $\approx$ 1-2ms
\end{frame}

\begin{frame}{Overhead на създаване на нишки}
\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        ybar,
        bar width=20pt,
        ylabel={Време (ms)},
        symbolic x coords={Създаване, Енкюиране в Pool},
        xtick=data,
        nodes near coords,
        nodes near coords align={vertical},
        ymin=0,
        ymax=120,
        width=10cm,
        height=6cm,
        legend style={at={(0.5,-0.15)}, anchor=north, legend columns=-1}
    ]
    \addplot coordinates {(Създаване,100) (Енкюиране в Pool,2)};
    \legend{1000 задачи}
    \end{axis}
\end{tikzpicture}
\end{center}

\textbf{Заключение:} Thread Pool е 50x по-бърз за множество малки задачи!
\end{frame}

\subsection{Предизвикателства}

\begin{frame}[fragile]{Предизвикателство: Синхронизация на опашката}

\textbf{Проблем:} Споделена опашка изисква lock за защита от race conditions

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
class ThreadPool {
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;  // <-- КРИТИЧНА СЕКЦИЯ
    std::condition_variable condition;
    
    void worker_thread() {
        while (true) {
            std::function<void()> task;
            {
                std::unique_lock<std::mutex> lock(queue_mutex);  // LOCK!
                condition.wait(lock, [this] { return stop || !tasks.empty(); });
                if (stop && tasks.empty()) return;
                task = std::move(tasks.front());
                tasks.pop();
            }  // Unlock тук
            task();  // Изпълнение извън lock-а
        }
    }
};
\end{lstlisting}

\textbf{Bottleneck:} Всички нишки се конкурират за един mutex!
\end{frame}

\begin{frame}{Проблеми със standard mutex}
\begin{center}
\begin{tikzpicture}[scale=0.85]
    % Queue
    \node[rectangle, draw, thick, minimum width=3cm, minimum height=1cm, fill=yellow!20] (queue) at (0,2) {Task Queue};
    \node[rectangle, draw, thick, minimum width=3cm, minimum height=0.6cm, fill=red!30] (mutex) at (0,0.8) {Mutex (locked)};
    
    % Threads waiting
    \node[circle, draw, fill=blue!20] (t1) at (-3,-1) {T1};
    \node[circle, draw, fill=blue!20] (t2) at (-1.5,-1) {T2};
    \node[circle, draw, fill=green!20] (t3) at (0,-1) {T3};
    \node[circle, draw, fill=blue!20] (t4) at (1.5,-1) {T4};
    \node[circle, draw, fill=blue!20] (t5) at (3,-1) {T5};
    
    % Arrows
    \draw[-Latex, thick] (t1) -- (mutex);
    \draw[-Latex, thick] (t2) -- (mutex);
    \draw[-Latex, thick, green!60!black, line width=1.5pt] (t3) -- (mutex) node[midway, right] {\tiny owns};
    \draw[-Latex, thick] (t4) -- (mutex);
    \draw[-Latex, thick] (t5) -- (mutex);
    
    \node[below, red] at (0,-2) {Contention: 4 нишки чакат, само 1 работи!};
\end{tikzpicture}
\end{center}

\textbf{Последици:}
\begin{itemize}
    \item Context switching
    \item Cache invalidation
    \item Намалена throughput при много нишки
\end{itemize}
\end{frame}

\subsection{Lock-Free Queues}

\begin{frame}{Lock-Free структури: Концепция}

\textbf{Идея:} Използване на атомарни операции вместо mutex

\begin{columns}
\column{0.48\textwidth}
\textbf{Lock-based:}
\begin{itemize}
    \item[$\times$] Blocking
    \item[$\times$] Contention
    \item[$\times$] Priority inversion
    \item[$\times$] Deadlock риск
    \item[\checkmark] По-лесна имплементация
\end{itemize}

\column{0.48\textwidth}
\textbf{Lock-free:}
\begin{itemize}
    \item[\checkmark] Non-blocking
    \item[\checkmark] No contention
    \item[\checkmark] Wait-free progress
    \item[\checkmark] По-висока throughput
    \item[$\times$] Сложна имплементация
\end{itemize}
\end{columns}

\vspace{0.5cm}

\textbf{Ключови техники:}
\begin{itemize}
    \item Compare-And-Swap (CAS): \texttt{std::atomic::compare\_exchange\_weak}
    \item Memory ordering: \texttt{memory\_order\_acquire}, \texttt{memory\_order\_release}
    \item ABA problem решения (tagged pointers, hazard pointers)
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Lock-Free Queue: Концепция}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
template<typename T>
class LockFreeQueue {
    struct Node {
        std::shared_ptr<T> data;
        std::atomic<Node*> next;
        Node() : next(nullptr) {}
    };
    
    std::atomic<Node*> head;
    std::atomic<Node*> tail;
    
public:
    void enqueue(T value) {
        auto new_node = new Node();
        new_node->data = std::make_shared<T>(std::move(value));
        
        Node* old_tail = tail.load(std::memory_order_relaxed);
        while (!tail.compare_exchange_weak(old_tail, new_node, 
               std::memory_order_release, std::memory_order_relaxed)) {
            // Retry ако друга нишка промени tail
        }
        old_tail->next.store(new_node, std::memory_order_release);
    }
    
    std::shared_ptr<T> dequeue() {
        Node* old_head = head.load(std::memory_order_acquire);
        while (old_head && !head.compare_exchange_weak(old_head, 
               old_head->next.load(), std::memory_order_release)) {
            // Retry
        }
        return old_head ? old_head->data : nullptr;
    }
};
\end{lstlisting}
\end{frame}

\begin{frame}{Lock-Free vs Lock-Based: Performance}
\begin{center}
\begin{tikzpicture}
    \begin{axis}[
        xlabel={Брой нишки},
        ylabel={Operations/sec (millions)},
        xmin=1, xmax=16,
        ymin=0, ymax=100,
        xtick={1,2,4,8,16},
        ytick={0,20,40,60,80,100},
        legend pos=north west,
        width=10cm,
        height=6cm,
        grid=major
    ]
    \addplot[color=blue, mark=square, thick] coordinates {
        (1,40) (2,45) (4,50) (8,55) (16,60)
    };
    \addplot[color=red, mark=*, thick] coordinates {
        (1,40) (2,70) (4,85) (8,92) (16,95)
    };
    \legend{Lock-based, Lock-free}
    \end{axis}
\end{tikzpicture}
\end{center}

\textbf{Забележка:} Lock-free структури scaling-ват много по-добре!
\end{frame}

\subsection{Примерна имплементация}

\begin{frame}[fragile]{Thread Pool с Lock-Based Queue}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
class ThreadPool {
    std::vector<std::thread> workers;
    std::queue<std::function<void()>> tasks;
    std::mutex queue_mutex;
    std::condition_variable condition;
    bool stop = false;

public:
    ThreadPool(size_t threads) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;
                    {
                        std::unique_lock<std::mutex> lock(queue_mutex);
                        condition.wait(lock, [this] { 
                            return stop || !tasks.empty(); 
                        });
                        if (stop && tasks.empty()) return;
                        task = std::move(tasks.front());
                        tasks.pop();
                    }
                    task(); // Изпълнение извън lock-а
                }
            });
        }
    }
    // enqueue(), destructor...
};
\end{lstlisting}
\end{frame}

\section{Coroutines}

\subsection{Концепция}

\begin{frame}{Coroutines: Какво са?}

\textbf{Определение:} Функции, които могат да suspend-ват и resume-ват изпълнението си

\begin{center}
\begin{tikzpicture}[scale=0.9]
    % Timeline
    \draw[-Latex, thick] (0,0) -- (10,0) node[right] {Време};
    
    % Normal function
    \draw[fill=blue!30, thick] (0.5,1.5) rectangle (2,2) node[pos=.5] {\tiny Task A};
    \draw[fill=green!30, thick] (2.5,1.5) rectangle (4,2) node[pos=.5] {\tiny Task B};
    \draw[fill=red!30, thick] (4.5,1.5) rectangle (6,2) node[pos=.5] {\tiny Task C};
    \node[left] at (0,1.75) {Нормални функции:};
    
    % Coroutines
    \draw[fill=blue!30, thick] (0.5,0.3) rectangle (1.5,0.8) node[pos=.5] {\tiny A};
    \draw[fill=green!30, thick] (1.6,0.3) rectangle (2.6,0.8) node[pos=.5] {\tiny B};
    \draw[fill=blue!30, thick] (2.7,0.3) rectangle (3.7,0.8) node[pos=.5] {\tiny A};
    \draw[fill=red!30, thick] (3.8,0.3) rectangle (4.8,0.8) node[pos=.5] {\tiny C};
    \draw[fill=green!30, thick] (4.9,0.3) rectangle (5.9,0.8) node[pos=.5] {\tiny B};
    \draw[fill=blue!30, thick] (6.0,0.3) rectangle (7.0,0.8) node[pos=.5] {\tiny A};
    \node[left] at (0,0.55) {Coroutines:};
\end{tikzpicture}
\end{center}

\textbf{Ключови думи в C++20:}
\begin{itemize}
    \item \texttt{co\_await} – suspend и чакане на резултат
    \item \texttt{co\_yield} – връщане на междинна стойност
    \item \texttt{co\_return} – завършване на coroutine
\end{itemize}
\end{frame}

\begin{frame}{Threads vs Coroutines}
\begin{columns}
\column{0.48\textwidth}
\textbf{Threads (OS-level):}
\begin{itemize}
    \item Управлявани от ОС
    \item Преемптивен scheduling
    \item Тежки (MB stack)
    \item Context switch \textasciitilde 1-10$\mu$s
    \item Паралелно изпълнение
    \item Използват множество ядра
\end{itemize}

\column{0.48\textwidth}
\textbf{Coroutines (user-level):}
\begin{itemize}
    \item Управлявани от програмата
    \item Кооперативен scheduling
    \item Леки (KB state)
    \item Context switch \textasciitilde 10-100ns
    \item Конкурентно, не паралелно
    \item Едно ядро (освен ако...)
\end{itemize}
\end{columns}

\vspace{0.5cm}
\centering
\textbf{Идеално:} Coroutines за I/O, Threads за CPU-intensive работа
\end{frame}

\subsection{Как работят и защо са по-евтини?}

\begin{frame}{Coroutines: Механизъм на работа}

\textbf{Традиционна функция:}
\begin{itemize}
    \item Stack frame се създава при извикване
    \item Изпълнение до return
    \item Stack frame се унищожава
    \item Невъзможно повторно влизане
\end{itemize}

\vspace{0.3cm}

\textbf{Coroutine:}
\begin{itemize}
    \item Състоянието се съхранява в heap (coroutine frame)
    \item \texttt{co\_await} запазва локални променливи и позиция
    \item Контролът се връща на caller-а
    \item По-късно се resume-ва от същата позиция
\end{itemize}

\vspace{0.3cm}

\textbf{Защо са по-евтини от threads?}
\begin{enumerate}
    \item Без system calls за context switching
    \item Малко състояние (само локални променливи)
    \item Без thread stack (1-2 MB спестени)
    \item Compiler оптимизации (inline възможни)
\end{enumerate}
\end{frame}

\begin{frame}{Memory Layout: Thread vs Coroutine}
\begin{center}
\begin{tikzpicture}[scale=0.8]
    % Thread
    \node[font=\bfseries] at (-3,4) {Thread};
    \draw[fill=red!20, thick] (-5,0) rectangle (-3,3.5) node[pos=.5, rotate=90] {Stack (1-2 MB)};
    \draw[fill=blue!20, thick] (-2.8,0) rectangle (-1,0.5) node[pos=.5] {\tiny TCB};
    \node[below] at (-3,-0.5) {OS Managed};
    
    % Coroutine
    \node[font=\bfseries] at (3,4) {Coroutine};
    \draw[fill=green!20, thick] (1.5,2.5) rectangle (4.5,3.5) node[pos=.5] {Coroutine Frame};
    \node[below, font=\tiny] at (3,2.3) {Local vars + Resume point};
    \node[below, font=\tiny] at (3,2.0) {Typically < 1 KB};
    \draw[fill=yellow!20, thick] (1.5,1) rectangle (4.5,1.5) node[pos=.5] {\tiny Promise};
    \node[below] at (3,0.2) {Heap Allocated};
\end{tikzpicture}
\end{center}

\textbf{Резултат:} Можем да имаме милиони coroutines, но само стотици threads!
\end{frame}

\subsection{Предизвикателства}

\begin{frame}[fragile]{Предизвикателство: Bus Errors и Stack Overflow}

\textbf{Проблем 1: Неправилно използване на указатели}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
Task<int> dangerous_coroutine() {
    int local_var = 42;
    co_await some_async_operation();
    // Ако coroutine се премести в друга нишка,
    // stack-allocated променливи могат да станат невалидни!
    return local_var;  // Потенциален bus error!
}
\end{lstlisting}

\textbf{Проблем 2: Lifetime на локални променливи}

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
Task<void> reference_problem() {
    std::string temp = "dangerous";
    auto& ref = temp;
    
    co_await switch_thread();  // Преминаване към друга нишка
    
    std::cout << ref;  // UNDEFINED BEHAVIOR! temp вече не съществува
}
\end{lstlisting}

\textbf{Решение:}
\begin{itemize}
    \item Всички данни в coroutine frame (не на stack)
    \item Избягвайте references към локални променливи
    \item Използвайте \texttt{std::move} или копиране
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Предизвикателство: Debugging и Stack Traces}

\textbf{Проблем:} Coroutines нямат традиционен stack trace

\begin{lstlisting}[basicstyle=\ttfamily\tiny]
Task<void> level3() {
    co_await std::suspend_always{};
    throw std::runtime_error("Error!");  // Къде е stack trace-а?
}

Task<void> level2() {
    co_await level3();
}

Task<void> level1() {
    co_await level2();
}

// При exception, debugger показва само текущата coroutine,
// не целия "async call stack"
\end{lstlisting}

\textbf{Решения:}
\begin{itemize}
    \item Използвайте coroutine-aware debuggers (LLDB, Visual Studio)
    \item Логване на входни/изходни точки
    \item Custom promise types с трacing
\end{itemize}
\end{frame}

\subsection{Примерна имплементация}

\begin{frame}[fragile]{Проста Coroutine имплементация (C++20)}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
#include <coroutine>
#include <iostream>

template<typename T>
struct Task {
    struct promise_type {
        T value;
        
        Task get_return_object() {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void unhandled_exception() { std::terminate(); }
        
        void return_value(T v) { value = v; }
    };
    
    std::coroutine_handle<promise_type> handle;
    
    T get() { return handle.promise().value; }
    ~Task() { if (handle) handle.destroy(); }
};

Task<int> async_computation() {
    std::cout << "Starting...\n";
    co_await std::suspend_always{};  // Suspend тук
    std::cout << "Resuming...\n";
    co_return 42;
}

int main() {
    auto task = async_computation();  // Стартира, спира на co_await
    task.handle.resume();  // Продължава изпълнението
    std::cout << "Result: " << task.get() << "\n";
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Реален пример: Async I/O с Coroutines}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
Task<std::string> async_read_file(const std::string& filename) {
    // Simulate async file reading
    co_await async_open(filename);
    std::string content;
    
    while (true) {
        auto chunk = co_await async_read_chunk();
        if (chunk.empty()) break;
        content += chunk;
    }
    
    co_await async_close();
    co_return content;
}

Task<void> process_files() {
    // Множество паралелни четения (но в една нишка!)
    auto file1 = async_read_file("data1.txt");
    auto file2 = async_read_file("data2.txt");
    auto file3 = async_read_file("data3.txt");
    
    // Чакаме всички
    auto content1 = co_await file1;
    auto content2 = co_await file2;
    auto content3 = co_await file3;
    
    // Обработка...
    std::cout << "Total size: " << content1.size() + content2.size() + content3.size();
}
\end{lstlisting}

\textbf{Предимство:} Хиляди едновременни I/O операции без хиляди threads!
\end{frame}

\section{Publisher/Subscriber Pattern}

\subsection{Концепция}

\begin{frame}{Publisher/Subscriber: Design Pattern}
\begin{center}
\begin{tikzpicture}[scale=0.85, 
    publisher/.style={rectangle, draw, fill=green!20, minimum width=2cm, minimum height=1cm},
    subscriber/.style={rectangle, draw, fill=blue!20, minimum width=1.8cm, minimum height=0.8cm},
    broker/.style={ellipse, draw, fill=yellow!20, minimum width=2.5cm, minimum height=1.5cm, align=center}]
    
    \node[publisher] (pub1) at (0,3) {Publisher 1};
    \node[publisher] (pub2) at (0,1) {Publisher 2};
    
    \node[broker] (broker) at (4,2) {Event\\Broker};
    
    \node[subscriber] (sub1) at (8,3.5) {Subscriber A};
    \node[subscriber] (sub2) at (8,2) {Subscriber B};
    \node[subscriber] (sub3) at (8,0.5) {Subscriber C};
    
    \draw[-Latex, thick] (pub1) -- (broker) node[midway, above] {\tiny publish};
    \draw[-Latex, thick] (pub2) -- (broker) node[midway, below] {\tiny publish};
    
    \draw[-Latex, thick] (broker) -- (sub1) node[midway, above] {\tiny notify};
    \draw[-Latex, thick] (broker) -- (sub2) node[midway, above] {\tiny notify};
    \draw[-Latex, thick] (broker) -- (sub3) node[midway, below] {\tiny notify};
\end{tikzpicture}
\end{center}

\textbf{Определение:} Architectural pattern за асинхронна комуникация

\textbf{Компоненти:}
\begin{itemize}
    \item \textbf{Publisher} – генерира събития/съобщения
    \item \textbf{Subscriber} – регистрира интерес и обработва
    \item \textbf{Event Broker} – посредник (loose coupling)
\end{itemize}
\end{frame}

\begin{frame}{Защо Pub/Sub Pattern?}

\textbf{Проблеми на директната комуникация:}
\begin{itemize}
    \item Tight coupling между компоненти
    \item Трудно масштабиране
    \item Промяна в един компонент засяга много други
\end{itemize}

\vspace{0.4cm}

\textbf{Предимства на Pub/Sub:}
\begin{itemize}
    \item[\checkmark] \textbf{Loose coupling} – publishers не знаят за subscribers
    \item[\checkmark] \textbf{Scalability} – добавяне на subscribers без промяна
    \item[\checkmark] \textbf{Flexibility} – динамична (не)регистрация
    \item[\checkmark] \textbf{Асинхронност} – non-blocking communication
\end{itemize}

\vspace{0.4cm}

\textbf{vs Observer Pattern:}
\begin{itemize}
    \item Observer = synchronous, директна връзка
    \item Pub/Sub = asynchronous, чрез посредник (broker)
\end{itemize}
\end{frame}

\subsection{Приложения}

\begin{frame}{Къде се използва Pub/Sub?}

\textbf{Event-Driven Архитектури}
\begin{itemize}
    \item GUI Applications (button clicks, window events)
    \item Game engines (collision events, state changes)
\end{itemize}

\textbf{Microservices Communication}
\begin{itemize}
    \item Distributed systems (RabbitMQ, Apache Kafka)
    \item Service orchestration
\end{itemize}

\textbf{Real-Time Data Processing}
\begin{itemize}
    \item Stock market data feeds
    \item IoT sensor networks
    \item Log aggregation systems
\end{itemize}

\textbf{Reactive Programming}
\begin{itemize}
    \item RxCpp (Reactive Extensions)
    \item Async data streams
\end{itemize}
\end{frame}

\begin{frame}{Примери от практиката}
\begin{columns}
\column{0.48\textwidth}
\textbf{Financial Trading System:}
\begin{enumerate}
    \item Market data feed (publisher)
    \item Risk engine (subscriber)
    \item Trading strategies (subscribers)
    \item Compliance monitor (subscriber)
    \item Logging system (subscriber)
\end{enumerate}

\textit{Всички компоненти получават същите данни, но ги обработват различно}

\column{0.48\textwidth}
\textbf{IoT Smart Home:}
\begin{enumerate}
    \item Temperature sensor (publisher)
    \item Heating system (subscriber)
    \item Mobile app (subscriber)
    \item Data logger (subscriber)
    \item Alert system (subscriber)
\end{enumerate}

\textit{Едно събитие тригерва множество реакции}
\end{columns}
\end{frame}

\subsection{Предизвикателства}

\begin{frame}{Предизвикателство 1: Гаранции за доставка}

\textbf{Проблем:} Какво ако subscriber не получи съобщението?

\vspace{0.3cm}

\textbf{Опции за доставка:}
\begin{enumerate}
    \item \textbf{At-most-once} – "fire and forget"
    \begin{itemize}
        \item Най-бързо, но може да се загуби
        \item Подходящо за некритични данни (metrics)
    \end{itemize}
    
    \item \textbf{At-least-once} – retry при неуспех
    \begin{itemize}
        \item Може да има дубликати
        \item Нуждае се от idempotent обработка
    \end{itemize}
    
    \item \textbf{Exactly-once} – гарантирана еднократна доставка
    \begin{itemize}
        \item Най-сложно, изисква транзакции
        \item Критични системи (payments, medical)
    \end{itemize}
\end{enumerate}

\vspace{0.3cm}
\textbf{Trade-off:} Надеждност vs Performance
\end{frame}

\begin{frame}{Предизвикателство 2: Backpressure}

\textbf{Проблем:} Publisher генерира събития по-бързо, отколкото subscribers могат да обработят

\begin{center}
\begin{tikzpicture}[scale=0.8]
    % Fast publisher
    \node[rectangle, draw, fill=red!40] at (0,2) {Fast Publisher};
    \draw[-Latex, very thick, red] (1.5,2) -- (3,2) node[midway, above] {\tiny 10000 msg/s};
    
    % Queue
    \node[rectangle, draw, fill=yellow!30, minimum width=2cm, minimum height=1.5cm] (queue) at (4.5,2) {};
    \foreach \y in {1.5,1.7,1.9,2.1,2.3,2.5,2.7} {
        \draw[fill=orange!20] (3.7,\y) rectangle (5.3,\y+0.15);
    }
    \node[above] at (4.5,2.8) {\tiny Queue};
    \node[below, red] at (4.5,1.2) {\tiny OVERFLOW!};
    
    % Slow subscriber
    \node[rectangle, draw, fill=blue!20] at (8,2) {Slow Subscriber};
    \draw[-Latex, thick, blue] (6,2) -- (7,2) node[midway, above] {\tiny 100 msg/s};
\end{tikzpicture}
\end{center}

\textbf{Решения:}
\begin{itemize}
    \item Buffering с bounded queue
    \item Dropping (отпадане на стари съобщения)
    \item Throttling (забавяне на publisher-а)
    \item Паралелизация на subscribers (нашата тема!)
\end{itemize}
\end{frame}

\begin{frame}{Предизвикателство 3: Ordering}

\textbf{Проблем:} Запазване на реда на съобщенията при паралелна обработка

\begin{lstlisting}[basicstyle=\ttfamily\tiny, language=C++]
// Publisher изпраща: Message 1, 2, 3
publisher.publish(msg1);
publisher.publish(msg2);
publisher.publish(msg3);

// Subscriber с thread pool може да получи: 2, 1, 3
// заради паралелна обработка!
\end{lstlisting}

\textbf{Решения:}
\begin{enumerate}
    \item \textbf{Single-threaded processing} – губим паралелизъм
    \item \textbf{Partition-based} – групи съобщения с гарантиран ред
    \item \textbf{Sequence numbers} – преподреждане след обработка
    \item \textbf{Per-key ordering} – само свързани съобщения се подреждат
\end{enumerate}
\end{frame}

\subsection{Примерна имплементация}

\begin{frame}[fragile]{Проста Pub/Sub имплементация}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
template<typename Event>
class EventBroker {
    using Subscriber = std::function<void(const Event&)>;
    using SubscriberId = size_t;
    
    std::unordered_map<SubscriberId, Subscriber> subscribers;
    std::mutex mutex;
    SubscriberId next_id = 0;

public:
    SubscriberId subscribe(Subscriber&& callback) {
        std::lock_guard<std::mutex> lock(mutex);
        auto id = next_id++;
        subscribers[id] = std::move(callback);
        return id;
    }
    
    void unsubscribe(SubscriberId id) {
        std::lock_guard<std::mutex> lock(mutex);
        subscribers.erase(id);
    }

    void publish(const Event& event) {
        std::lock_guard<std::mutex> lock(mutex);
        for (auto& [id, subscriber] : subscribers) {
            subscriber(event);  // Синхронно извикване
        }
    }
};
\end{lstlisting}

\textbf{Проблем:} publish() блокира до обработка на всички subscribers!
\end{frame}

\begin{frame}[fragile]{Асинхронна имплементация с Thread Pool}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
template<typename Event>
class AsyncEventBroker {
    using Subscriber = std::function<void(const Event&)>;
    std::vector<Subscriber> subscribers;
    ThreadPool pool;
    std::mutex mutex;

public:
    AsyncEventBroker(size_t num_threads = std::thread::hardware_concurrency())
        : pool(num_threads) {}
    
    void subscribe(Subscriber&& callback) {
        std::lock_guard<std::mutex> lock(mutex);
        subscribers.push_back(std::move(callback));
    }

    void publish(const Event& event) {
        std::lock_guard<std::mutex> lock(mutex);
        // Всеки subscriber се обработва в отделна задача
        for (auto& subscriber : subscribers) {
            pool.enqueue([subscriber, event]() {
                subscriber(event);  // Паралелно изпълнение!
            });
        }
    }  // publish() не чака обработката
};
\end{lstlisting}

\textbf{Предимство:} Non-blocking publish(), паралелна обработка!
\end{frame}

\subsection{Паралелизирано разпращане}

\begin{frame}{Паралелизация на subscriber dispatch}

\textbf{Проблем:} Наивната имплементация има serialization bottleneck

\begin{center}
\begin{tikzpicture}[scale=0.75]
    % Naive approach
    \node[font=\bfseries] at (0,4) {Наивен подход};
    \node[rectangle, draw, fill=red!20] (pub) at (0,3) {Publisher};
    \node[rectangle, draw, fill=yellow!30] (broker) at (0,1.8) {Broker (mutex)};
    
    \draw[-Latex, thick] (pub) -- (broker);
    \draw[-Latex, thick] (broker.east) -- ++(1,0) |- (2,2.5) node[right] {\tiny Sub1};
    \draw[-Latex, thick] (broker.east) -- ++(1,0) |- (2,2.0) node[right] {\tiny Sub2};
    \draw[-Latex, thick] (broker.east) -- ++(1,0) |- (2,1.5) node[right] {\tiny Sub3};
    \node[below, red] at (0,0.8) {\tiny Serialization!};
    
    % Optimized approach
    \node[font=\bfseries] at (7,4) {Оптимизиран подход};
    \node[rectangle, draw, fill=red!20] (pub2) at (7,3) {Publisher};
    \node[rectangle, draw, fill=green!30] (broker2) at (7,1.8) {Lock-free Broker};
    
    \draw[-Latex, thick, green!60!black] (pub2) -- (broker2);
    \draw[-Latex, thick, green!60!black] (broker2) -- ++(1.5,0) |- (9.5,2.5) node[right] {\tiny Sub1};
    \draw[-Latex, thick, green!60!black] (broker2) -- ++(1.5,0) |- (9.5,2.0) node[right] {\tiny Sub2};
    \draw[-Latex, thick, green!60!black] (broker2) -- ++(1.5,0) |- (9.5,1.5) node[right] {\tiny Sub3};
    \node[below, green!60!black] at (7,0.8) {\tiny Паралелно!};
\end{tikzpicture}
\end{center}

\textbf{Техники за оптимизация:}
\begin{itemize}
    \item Lock-free subscriber list (RCU - Read-Copy-Update)
    \item Per-subscriber queue вместо centralized
    \item Wait-free publish операции
    \item Batch processing на множество събития
\end{itemize}
\end{frame}

\begin{frame}{Научна работа: Паралелизирано разпращане на съобщения}

\textbf{Заглавие:} "Efficient Parallelized Message Dispatching in Publisher/Subscriber Systems"

\vspace{0.3cm}

\textbf{Основни приноси:}
\begin{enumerate}
    \item \textbf{Lock-free dispatch algorithm}
    \begin{itemize}
        \item CAS-based subscriber registration
        \item Wait-free publish() имплементация
        \item RCU за безопасно четене на subscriber list
    \end{itemize}
    
    \item \textbf{Thread Pool integration}
    \begin{itemize}
        \item Work-stealing за балансировка
        \item Subscriber affinity за cache locality
    \end{itemize}
    
    \item \textbf{Performance benchmarks}
    \begin{itemize}
        \item 10x throughput подобрение при 16+ subscribers
        \item 50\% latency редукция спрямо mutex-based подход
        \item Scaling до 128 CPU cores
    \end{itemize}
\end{enumerate}

\vspace{0.3cm}
\centering
\textit{Комбинацията Thread Pool + Lock-free Pub/Sub = High-Performance системи}
\end{frame}

\begin{frame}[fragile]{Code snippet от работата: RCU-based Subscriber List}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
template<typename Event>
class RCUEventBroker {
    struct SubscriberNode {
        std::function<void(const Event&)> callback;
        std::shared_ptr<SubscriberNode> next;
    };
    
    std::atomic<std::shared_ptr<SubscriberNode>> head;
    ThreadPool pool;

public:
    void subscribe(std::function<void(const Event&)> callback) {
        auto new_node = std::make_shared<SubscriberNode>();
        new_node->callback = std::move(callback);
        
        auto old_head = head.load(std::memory_order_acquire);
        do {
            new_node->next = old_head;
        } while (!head.compare_exchange_weak(old_head, new_node,
                 std::memory_order_release, std::memory_order_acquire));
    }
    
    void publish(const Event& event) {
        // Lock-free read
        auto node = head.load(std::memory_order_acquire);
        while (node) {
            pool.enqueue([cb = node->callback, event]() { cb(event); });
            node = node->next;
        }
    }
};
\end{lstlisting}
\end{frame}

\section{Комбиниране на техниките}

\begin{frame}{Интеграция: Thread Pool + Coroutines + Pub/Sub}
\begin{center}
\begin{tikzpicture}[scale=0.7,
    component/.style={rectangle, draw, rounded corners, minimum width=2.2cm, minimum height=0.8cm}]
    
    \node[component, fill=green!20] (source) at (0,4) {Data Source};
    \node[component, fill=yellow!20] (pub) at (0,2.5) {Publisher};
    \node[component, fill=orange!20] (broker) at (5,2.5) {Event Broker};
    
    \node[component, fill=red!20] (pool) at (5,0.5) {Thread Pool};
    
    \node[component, fill=blue!20, align=center] (sub1) at (10,3.5) {Subscriber 1\\Coroutine};
    \node[component, fill=blue!20, align=center] (sub2) at (10,2.5) {Subscriber 2\\CPU-bound};
    \node[component, fill=blue!20, align=center] (sub3) at (10,1.5) {Subscriber 3\\I/O-bound};
    
    \draw[-Latex, thick] (source) -- (pub);
    \draw[-Latex, thick] (pub) -- (broker) node[midway, above] {\tiny publish};
    \draw[-Latex, thick] (broker) -- (pool) node[midway, right] {\tiny dispatch};
    
    \draw[-Latex, thick, green!60!black] (pool.east) -- ++(1,0) |- (sub1.west);
    \draw[-Latex, thick, red] (pool.east) -- ++(1,0) |- (sub2.west);
    \draw[-Latex, thick, blue] (pool.east) -- ++(1,0) |- (sub3.west);
\end{tikzpicture}
\end{center}

\textbf{Hybrid подход:}
\begin{itemize}
    \item Thread Pool за паралелна обработка (CPU-intensive)
    \item Coroutines за I/O операции (networking, disk)
    \item Pub/Sub за декуплиране и организация
\end{itemize}
\end{frame}

\begin{frame}{Кога какво да използваме?}
\begin{table}
\centering
\small
\begin{tabular}{|l|l|l|}
\hline
\textbf{Задача} & \textbf{Техника} & \textbf{Защо?} \\
\hline
CPU-intensive & Thread Pool & Използва всички ядра \\
I/O операции & Coroutines & Ниски overhead, милиони conn \\
Event routing & Pub/Sub & Loose coupling \\
High-throughput & Lock-free + Pool & Минимизира contention \\
Mixed workload & Hybrid & Комбинира силни страни \\
\hline
\end{tabular}
\end{table}

\vspace{0.5cm}

\textbf{Практически съвет:}
\begin{enumerate}
    \item Измерете bottleneck-овете (профилиране!)
    \item Не оптимизирайте преждевременно
    \item Комбинирайте техники според нуждите
\end{enumerate}
\end{frame}

\section{Заключение}

\begin{frame}{Обобщение}
\textbf{Какво научихме днес:}

\begin{enumerate}
    \item \textbf{Thread Pools}
    \begin{itemize}
        \item Преизползване на нишки за ефективност
        \item Lock-based vs lock-free имплементации
        \item Цената на създаване на threads (50-100x!)
    \end{itemize}
    
    \item \textbf{Coroutines}
    \begin{itemize}
        \item Леки, кооперативни задачи
        \item Идеални за I/O-bound workloads
        \item 100x по-евтини от threads (KB vs MB)
    \end{itemize}
    
    \item \textbf{Publisher/Subscriber}
    \begin{itemize}
        \item Decoupling чрез event broker
        \item Паралелизирано разпращане на съобщения
        \item Препратка към научна работа
    \end{itemize}
    
    \item \textbf{Комбиниране}
    \begin{itemize}
        \item Hybrid архитектури за реални системи
    \end{itemize}
\end{enumerate}
\end{frame}

\begin{frame}{Връзка с курса}
\textbf{Модул 2: Комуникация между задачи}

\begin{itemize}
    \item Pub/Sub като message passing механизъм
    \item Lock-free structures за синхронизация
    \item Thread pools за task orchestration
\end{itemize}

\vspace{0.5cm}

\textbf{Scaling до distributed systems:}
\begin{itemize}
    \item ZeroMQ, RabbitMQ – distributed pub/sub
    \item Apache Kafka – event streaming
    \item gRPC, Protobuf – efficient serialization
\end{itemize}

\vspace{0.5cm}

\textbf{Допълнителни теми за изследване:}
\begin{itemize}
    \item Memory ordering (acquire/release semantics)
    \item Hazard pointers за garbage collection
    \item Transactional memory
\end{itemize}
\end{frame}

\begin{frame}{Препоръчителна литература}
\textbf{Книги:}
\begin{itemize}
    \item "C++ Concurrency in Action" – Anthony Williams
    \item "The Art of Multiprocessor Programming" – Herlihy \& Shavit
    \item "Programming with POSIX Threads" – David Butenhof
\end{itemize}

\vspace{0.3cm}

\textbf{Papers:}
\begin{itemize}
    \item "Lock-Free Data Structures" – Michael \& Scott
    \item "RCU (Read-Copy-Update)" – McKenney
    \item "Efficient Parallelized Message Dispatching" – (ваша работа!)
\end{itemize}

\vspace{0.3cm}

\textbf{Online ресурси:}
\begin{itemize}
    \item cppreference.com – coroutines, atomics
    \item preshing.com – lock-free programming
    \item 1024cores.net – Dmitry Vyukov's blog
\end{itemize}
\end{frame}

\begin{frame}{Въпроси и дискусия}
\centering
\Huge{Въпроси?}

\vspace{1cm}

\normalsize
\textbf{Теми за дискусия:}
\begin{itemize}
    \item ABA problem и решенията му
    \item Memory ordering в practice
    \item Profiling tools (perf, VTune, Tracy)
    \item Real-world case studies
    \item C++23/26 нововъведения (executors, async RAII)
\end{itemize}

\vspace{1cm}
\textit{Благодаря за вниманието!}

\vspace{0.5cm}
\small
Контакт: alex@example.com | GitHub: github.com/alex
\end{frame}

\end{document}
