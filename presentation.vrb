\frametitle{Code snippet от работата: RCU-based Subscriber List}
\begin{lstlisting}[basicstyle=\ttfamily\tiny]
template<typename Event>
class RCUEventBroker {
    struct SubscriberNode {
        std::function<void(const Event&)> callback;
        std::shared_ptr<SubscriberNode> next;
    };

    std::atomic<std::shared_ptr<SubscriberNode>> head;
    ThreadPool pool;

public:
    void subscribe(std::function<void(const Event&)> callback) {
        auto new_node = std::make_shared<SubscriberNode>();
        new_node->callback = std::move(callback);

        auto old_head = head.load(std::memory_order_acquire);
        do {
            new_node->next = old_head;
        } while (!head.compare_exchange_weak(old_head, new_node,
                 std::memory_order_release, std::memory_order_acquire));
    }

    void publish(const Event& event) {
        // Lock-free read
        auto node = head.load(std::memory_order_acquire);
        while (node) {
            pool.enqueue([cb = node->callback, event]() { cb(event); });
            node = node->next;
        }
    }
};
\end{lstlisting}
